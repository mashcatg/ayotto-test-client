import axios from "axios";
import { Trash2 } from "lucide-react";
import { useRef, useState } from "react";
import toast from "react-hot-toast";
import { CgSpinner } from "react-icons/cg";
import Swal from "sweetalert2";
import CustomEditor from "../../../../components/CustomEditor/CustomEditor";
import useAxios from "../../../../hooks/useAxios";
import { processHtmlContent } from "../../../../utils/imageProcessor";
import AddQuestionModal from "./AddQuestionModal";
import Categories from "./Categories";

const CreateQuestion = () => {
  const axiosPublic = useAxios();
  // states
  const [questions, setQuestions] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [image, setImage] = useState(null);
  const [imagePreview, setImagePreview] = useState("");
  const imageRef = useRef(null);
  const [isDragging, setIsDragging] = useState(false);
  const [isAiResponseLoading, setIsAiResponseLoading] = useState(false);
  const [type, setType] = useState("");
  const [topicId, setTopicId] = useState("");
  const [isSaving, setIsSaving] = useState(false);

  // utility functions

  // image functions
  const handleImageChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      setImage(file);
      setImagePreview(URL.createObjectURL(file));
    }
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragEnter = (e) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = (e) => {
    e.preventDefault();
    setIsDragging(false);
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith("image/")) {
      setImage(file);
      setImagePreview(URL.createObjectURL(file));
    }
  };

  const handleImageUpload = async () => {
    if (!image) {
      toast.error("Please select an image first");
      return;
    }

    console.log("Uploading image:", image);
    setIsAiResponseLoading(true);

    const reader = new FileReader();
    reader.readAsDataURL(image);
    reader.onloadend = async () => {
      const base64Image = reader.result.split(",")[1];

      const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
      const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;

      const prompt = `
      Analyze this image and extract multiple-choice questions (MCQs) exactly as they appear in the image. Maintain the original language and formatting.
      - If the image contains a stamp image, diagram, chart before any question, replace it with "[image here]".
      - Ensure every question has at least one correct answer. (But that is not generated by you)
      - If reference text or explanation (solution) exists, include them.
      - if question options starts with i, ii, iii then include the i,ii,iii in the question text and extra things will be options (e.g. i and ii)
      - Ignore all the stamp texts(e.g.: নিচের চিত্রের আলোতে ১০ ও ১১নং প্রশ্নের উত্তর দাও।). Also remove প্রয়োগ, অনুধাবন, উচ্চতর দক্ষতা, জ্ঞান if found.
      - Return ONLY raw JSON in this format:

      [
        {
          "questionText": "string",
          "isExtraImageExist": "", // if image exists, replace with [image here]
          "referenceText": "",
          "solutionText": "",
          "options": [
            { "text": "string", "isCorrect": boolean }
          ]
        }
      ]

      Rules:
      1. Extract all MCQs, not just one.
      2. Preserve exact wording. Keep the original language (do not translate).
      3. Replace all relevant details like diagrams or images or tables or other complex things with [image/diagram here].
      4. Return ONLY JSON, no explanations, no markdown or code blocks, no unneeded text.
      5. Return empty string for referenceText and solutionText if not applicable.
      6. Reference text can be inside [](e.g.: [ঢা. বি. ২০২৪-২৫] or [ঢাকা নটরডেম কলেজ, রাজশাহী সরকারি পাবলিক স্কুল] etc). Also, solutionText can be inside ব্যাখ্যা/Solution/Solve or any similar part(It might be bottom of the question).
      7. Create EXACT clones of question(s). Do not change anything of any question or answer.
      8. Never select multiple answers as correct. Never generate answer of any question from your side. just get the correct answer from surroundings(it can be ticked, lebeled, written or any other way)
      `.trim();

      const payload = {
        contents: [
          {
            parts: [
              { text: prompt },
              {
                inlineData: {
                  mimeType: image.type,
                  data: base64Image,
                },
              },
            ],
          },
        ],
      };

      try {
        const response = await axios.post(GEMINI_API_URL, payload, {
          headers: { "Content-Type": "application/json" },
        });

        const candidates = response.data?.candidates;
        if (!candidates?.length) {
          toast.error("No valid response from AI");
          return;
        }

        // Extract raw text from response
        let rawText = candidates[0]?.content?.parts[0]?.text || "";
        if (!rawText) {
          toast.error("Empty response from AI");
          return;
        }

        // Clean up JSON string
        rawText = rawText
          .replace(/```json\n/g, "") // Remove starting JSON marker
          .replace(/\n```/g, "") // Remove ending marker
          .trim();

        let parsedQuestions;
        try {
          parsedQuestions = JSON.parse(rawText);
        } catch (jsonError) {
          console.error("Error parsing JSON:", jsonError);
          toast.error("Failed to parse AI response");
          return;
        }

        // Transform and validate questions
        const formattedQuestions = parsedQuestions.map((q) => {
          // Remove question numbers from start if present
          const questionText = q.questionText.replace(/^\d+\.\s*/, "").trim();

          // Transform options array - note we're not escaping HTML now
          const questionOption = q.options.map((opt) => ({
            text: opt.text.replace(/\n/g, "<br>").trim(), // Convert newlines to HTML breaks
            isCorrect: opt.isCorrect,
          }));

          // Format solution text with HTML line breaks
          const solution = q.solutionText
            ?.replace(/^(ব্যাখ্যা|Solution|Solve)(:|\s)*/, "")
            .replace(/\n/g, "<br>") // Convert newlines to HTML breaks
            .trim();

          console.log(q);
          return {
            id: Date.now() + Math.random().toString(36).substring(2),
            questionText,
            questionOption,
            questionRef: q.referenceText || "",
            solution: solution || "",
            ...(q.isExtraImageExist ? { hasImage: true } : {}),
          };
        });

        // Validate formatted questions
        if (!formattedQuestions.length) {
          toast.error("No valid questions found in the response");
          return;
        }

        // Add to existing questions
        setQuestions((prev) => [...prev, ...formattedQuestions]);

        // Show success message with count
        toast.success(`${formattedQuestions.length} questions extracted successfully!`);

        // Log formatted output for debugging
        console.log("Formatted Questions:", formattedQuestions);
      } catch (error) {
        console.error("Error processing image:", error);
        console.error("Failed to process image. Check API key and response format.");
        toast.error("Failed to process image. Please try again.");
      } finally {
        setIsAiResponseLoading(false);

        // Clear the image state
        setImage(null);
        setImagePreview("");

        // Clear the input field
        if (imageRef.current) {
          imageRef.current.value = "";
        }
      }
    };
  };

  // change functions
  const handleQuestionChange = (questionIndex, field, value) => {
    setQuestions((prevQuestions) => {
      const newQuestions = [...prevQuestions];
      newQuestions[questionIndex] = {
        ...newQuestions[questionIndex],
        [field]: value,
      };
      return newQuestions;
    });
  };

  const handleOptionChange = (questionIndex, optionIndex, value) => {
    setQuestions((prevQuestions) => {
      const newQuestions = [...prevQuestions];
      newQuestions[questionIndex] = {
        ...newQuestions[questionIndex],
        questionOption: newQuestions[questionIndex].questionOption.map((opt, idx) => (idx === optionIndex ? { ...opt, text: value } : opt)),
      };
      return newQuestions;
    });
  };

  const handleCorrectAnswerChange = (questionIndex, optionIndex) => {
    setQuestions((prevQuestions) => {
      const newQuestions = [...prevQuestions];
      newQuestions[questionIndex] = {
        ...newQuestions[questionIndex],
        questionOption: newQuestions[questionIndex].questionOption.map((opt, idx) => ({
          ...opt,
          isCorrect: idx === optionIndex,
        })),
      };
      return newQuestions;
    });
  };

  const handleAddOption = (questionIndex) => {
    setQuestions((prevQuestions) => {
      const newQuestions = [...prevQuestions];
      newQuestions[questionIndex] = {
        ...newQuestions[questionIndex],
        questionOption: [...newQuestions[questionIndex].questionOption, { text: "", isCorrect: false }],
      };
      return newQuestions;
    });
  };

  const handleRemoveOption = (questionIndex, optionIndex) => {
    setQuestions((prevQuestions) => {
      const newQuestions = [...prevQuestions];
      newQuestions[questionIndex] = {
        ...newQuestions[questionIndex],
        questionOption: newQuestions[questionIndex].questionOption.filter((_, idx) => idx !== optionIndex),
      };
      return newQuestions;
    });
  };

  // modal functions
  const handleOpenModal = () => {
    setIsModalOpen(true);
  };

  // Save all questions
  const handleSaveAll = async () => {
    // Consolidate required field validations for each question
    if (questions.length === 0) {
      toast.error("No questions to save");
      return;
    }

    // Validate topicId
    if (!topicId) {
      toast.error("Please select a topic for all questions");
      return;
    }

    // Validate type field
    if (!type) {
      toast.error("Please select a type for all questions");
      return;
    }

    // Validate question text is not empty for any question
    if (questions.some((question) => !question.questionText.trim())) {
      toast.error("Question text is required for all questions");
      return;
    }

    // Validate each option text is not empty for any question
    if (questions.some((question) => question.questionOption.some((option) => !option.text.trim()))) {
      toast.error("Option text is required for all options");
      return;
    }

    // Validate at least one correct answer per question
    if (questions.some((question) => !question.questionOption.some((option) => option.isCorrect))) {
      toast.error("At least one option must be marked as correct for all questions");
      return;
    }

    // save all questions
    setIsSaving(true);

    try {
      // Process each question to replace base64 images with URLs
      const processedQuestions = await Promise.all(
        questions.map(async (question) => {
          // Process question text
          const processedQuestionText = await processHtmlContent(question.questionText);

          // Process each option
          const processedOptions = await Promise.all(
            question.questionOption.map(async (option) => ({
              ...option,
              text: await processHtmlContent(option.text),
            }))
          );

          // Process solution
          const processedSolution = await processHtmlContent(question.solution);

          // Return processed question
          return {
            ...question,
            questionText: processedQuestionText,
            questionOption: processedOptions,
            solution: processedSolution,
          };
        })
      );

      // Now send the processed data to the server
      const data = {
        questions: processedQuestions,
        topicId,
        type,
      };

      const response = await axiosPublic.post("/question", data);
      console.log("Response from API:", response.data);

      setQuestions([]);
      toast.success("Questions saved successfully!");

      // Show detailed error in console for debugging
      if (error.response?.data) {
        console.error("Server error details:", error.response.data);
      }
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="py-6">
      {isSaving && (
        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center">
          <div className="bg-white p-8 rounded-xl shadow-xl max-w-md w-full mx-4">
            <div className="flex flex-col items-center">
              <CgSpinner className="animate-spin w-12 h-12 text-primary mb-4" />
              <h3 className="text-lg font-medium text-gray-900 mb-2">Saving Questions...</h3>
              <p className="text-sm text-gray-500 text-center">Please wait while we save your questions. This may take a moment.</p>
            </div>
          </div>
        </div>
      )}

      {/* categories */}
      <Categories props={{ topicId, setTopicId }}></Categories>

      {/* type buttons */}
      <div className="flex flex-wrap gap-2 mb-6">
        <select
          onChange={(e) => setType(e.target.value)}
          className="bg-[#E9E4E4] hover:bg-gray-200 text-[#6a6b6c] text-sm  rounded-xl px-4 py-2 flex items-center"
        >
          <option value="">Select Type</option>
          <option value="board">Board</option>
          <option value="test">Test</option>
          <option value="others">Others</option>
        </select>
      </div>

      {/* Upload Section */}
      <div
        className={`mb-6 bg-primary/5 rounded-xl text-center border-2 border-dashed border-primary/20 hover:bg-primary/10 transition-colors ${
          isDragging ? "bg-primary/10" : ""
        }`}
        onDragOver={handleDragOver}
        onDragEnter={handleDragEnter}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
      >
        <div className="relative flex flex-col items-center">
          <input ref={imageRef} type="file" accept="image/*" className="opacity-0 absolute size-full cursor-pointer" onChange={handleImageChange} />
          <div className="p-8 flex flex-col items-center">
            {isAiResponseLoading ? (
              <div className="flex items-center gap-2">
                <CgSpinner className="animate-spin w-6 h-6 text-primary" />
                <p className="text-primary">Generating Questions...</p>
              </div>
            ) : (
              <>
                {imagePreview ? (
                  <img src={imagePreview} alt="image preview" className="w-full h-48 object-cover rounded-xl" />
                ) : (
                  <>
                    <svg className="w-12 h-12 text-primary mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth="2"
                        d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                      />
                    </svg>
                    <p className="text-primary mb-1">Upload Question Image</p>
                    <p className="text-sm text-gray-500">Drag your image to extract questions via AI</p>
                  </>
                )}
              </>
            )}
          </div>
        </div>
      </div>

      {/* Generate Questions Button */}
      <div className="flex flex-wrap gap-5 sm:flex-nowrap justify-center sm:justify-between mb-6">
        <button
          onClick={handleImageUpload}
          className="bg-primary hover:bg-primary/90 text-white px-6 py-2 rounded-xl flex items-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={isAiResponseLoading}
        >
          <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
          </svg>
          Generate Questions
        </button>
        <button onClick={handleOpenModal} className="text-primary bg-primary/5 px-6 py-2 rounded-xl flex items-center duration-300 hover:bg-primary/10">
          <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" />
          </svg>
          Add Question
        </button>
      </div>

      {/* Extracted Questions Section */}
      <div className="bg-primary/5 border-primary/50 border p-6 rounded-xl">
        <h2 className="text-primary text-2xl font-medium mb-4">Extracted Questions</h2>

        {questions.length === 0 ? (
          <div className="text-center py-8">
            <svg className="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z"
              />
            </svg>
            <h3 className="mt-2 text-sm font-medium text-gray-900">No questions yet</h3>
            <p className="mt-1 text-sm text-gray-500">Get started by uploading an image or adding a question manually</p>
            <div className="mt-6 flex justify-center gap-3">
              <button
                onClick={handleImageUpload}
                className="bg-primary/10 text-primary hover:bg-primary/20 px-4 py-2 rounded-xl flex items-center transition-colors"
                disabled={isAiResponseLoading}
              >
                <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                  />
                </svg>
                Upload Image
              </button>
              <button onClick={handleOpenModal} className="bg-primary text-white hover:bg-primary/90 px-4 py-2 rounded-xl flex items-center transition-colors">
                <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" />
                </svg>
                Add Question
              </button>
            </div>
          </div>
        ) : (
          <>
            {/* Existing questions mapping code */}
            {questions.map((question, questionIdx) => (
              <div key={question.id || questionIdx} className="mb-8 last:mb-0">
                <div className="mb-4">
                  <div className="flex items-center justify-between">
                    <p className="font-medium mb-2">({questionIdx + 1}) Question Text:</p>

                    <button
                      onClick={() => {
                        Swal.fire({
                          title: "Are you sure?",
                          text: "You won't be able to revert this!",
                          icon: "warning",
                          showCancelButton: true,
                          confirmButtonColor: "#3085d6",
                          cancelButtonColor: "#d33",
                          confirmButtonText: "Yes, delete it!",
                        }).then((result) => {
                          if (result.isConfirmed) {
                            const questionToDelete = questions[questionIdx];
                            // Delete using a more reliable filter based on the unique ID
                            setQuestions((prevQuestions) => prevQuestions.filter((question) => question.id !== questionToDelete.id));
                            Swal.fire("Deleted!", "Your question has been deleted.", "success");
                          }
                        });
                      }}
                      className="text-red-500 hover:text-red-600"
                    >
                      Delete
                    </button>
                  </div>
                  <CustomEditor
                    value={question.questionText}
                    onChange={(value) => handleQuestionChange(questionIdx, "questionText", value)}
                    placeholder="Enter question text"
                  />
                </div>

                <div className="mb-4">
                  <p className="font-medium mb-2">Question Reference:</p>
                  <input
                    type="text"
                    placeholder="Enter reference text"
                    value={question.questionRef}
                    onChange={(e) => handleQuestionChange(questionIdx, "questionRef", e.target.value)}
                    className="w-full bg-white p-3 rounded-xl border border-transparent focus:border-primary/50 outline-none"
                  />
                </div>

                {question.questionOption.map((option, optIdx) => (
                  <div key={optIdx} className="mb-2">
                    <p className="font-medium mb-2">Option {optIdx + 1}:</p>
                    <div className={`flex flex-col rounded-xl bg-white`}>
                      <div className={`bg-white rounded-t-xl`}>
                        <CustomEditor
                          value={option.text}
                          onChange={(value) => handleOptionChange(questionIdx, optIdx, value)}
                          placeholder={`Enter option ${optIdx + 1} text`}
                        />
                      </div>
                      <div className="flex items-center justify-end p-2 rounded-b-xl border-t border-gray-200 bg-gray-50">
                        <div className="flex items-center">
                          <label className="mr-2 text-sm font-medium">Correct:</label>
                          <input
                            type="checkbox"
                            checked={option.isCorrect}
                            onChange={() => handleCorrectAnswerChange(questionIdx, optIdx)}
                            className="cursor-pointer"
                          />
                        </div>
                        <button onClick={() => handleRemoveOption(questionIdx, optIdx)} className="text-red-500 hover:text-red-600 ml-4" title="Remove option">
                          <Trash2 size={16} />
                        </button>
                      </div>
                    </div>
                  </div>
                ))}

                <button onClick={() => handleAddOption(questionIdx)} className="text-primary hover:text-primary/80 mt-2 flex items-center mb-2">
                  <svg className="size-4 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" />
                  </svg>
                  Add Option
                </button>

                <div className="mb-4">
                  <p className="font-medium mb-2">Solution:</p>
                  <CustomEditor
                    value={question.solution}
                    onChange={(value) => handleQuestionChange(questionIdx, "solution", value)}
                    placeholder="Enter solution explanation"
                  />
                </div>
              </div>
            ))}

            <button
              onClick={handleSaveAll}
              className="max-w-[400px] mx-auto block w-full bg-primary hover:bg-primary/80 text-white py-2 rounded-xl mt-6 transition-colors"
            >
              Save All Questions
            </button>
          </>
        )}
      </div>

      {/* Modal */}
      {isModalOpen && (
        <AddQuestionModal
          props={{
            setIsModalOpen,
            setQuestions,
          }}
        ></AddQuestionModal>
      )}
    </div>
  );
};

export default CreateQuestion;
